package routing

import (
	"math"
	"sort"

	"github.com/lintang-b-s/Navigatorx/pkg"
	"github.com/lintang-b-s/Navigatorx/pkg/datastructure"
	"github.com/lintang-b-s/Navigatorx/pkg/util"
)

/*
ref:
[1] Kobitzsch, M., Radermacher, M. and Schieferdecker, D. (2013) “Evolution and Evaluation of the Penalty Method for Alternative Graphs,” OASIcs, Volume 33, ATMOS 2013. Edited by D. Frigioni and S. Stiller, 33, pp. 94–107. Available at: https://doi.org/10.4230/OASICS.ATMOS.2013.94.
[2] Bader, R. et al. (2011) “Alternative Route Graphs in Road Networks,” in A. Marchetti-Spaccamela and M. Segal (eds.) Theory and Practice of Algorithms in (Computer) Systems. Berlin, Heidelberg: Springer, pp. 21–32. Available at: https://doi.org/10.1007/978-3-642-19754-3_5.
[3] Sinop, A.K. et al. (2021) “Robust Routing Using Electrical Flows,” in Proceedings of the 29th International Conference on Advances in Geographic Information Systems. New York, NY, USA: Association for Computing Machinery (SIGSPATIAL ’21), pp. 282–292. Available at: https://doi.org/10.1145/3474717.3483961.

The reason I want to apply the penalty method to calculate alternative routes is because the alternative routes generated by this method have better quality than the via-node/plateau method (abraham et al. (2013)) even though they have worse query time (based on experiments from paper [3]).
*/

// FindAlternativeRoutesPenaltyMethod. implement Algorithm CRP-π in paper [1]
func (ars *AlternativeRouteSearch) FindAlternativeRoutesPenaltyMethod(asId, atId datastructure.Index, k int, dist, optTravelTime float64,
	optEdgePath []datastructure.OutEdge, numSettledNodes int) []*AlternativeRoute {

	s := ars.engine.graph.GetOutEdge(asId).GetHead()
	t := ars.engine.graph.GetInEdge(atId).GetTail()

	var (
		altEdgePath []datastructure.OutEdge
		found       bool
	)

	altEdgePath = make([]datastructure.OutEdge, len(optEdgePath))
	copy(altEdgePath, optEdgePath)

	newGraphVertexMap := make(map[datastructure.Index]datastructure.Index)

	H := datastructure.NewDynamicGraph()
	graphEdgeSet := make(map[datastructure.Index]struct{})
	ars.updateGraph(newGraphVertexMap, graphEdgeSet, optEdgePath, H)

	altTravelTime := optTravelTime
	epsilon := ars.epsilon
	maxIter := 1
	if dist <= 7.0 {
		epsilon = 0.3
		maxIter = 3 * k
	} else if dist <= 10.0 {
		epsilon = 0.25
		maxIter = 3 * k
	}

	maxLevel := 3

	iteration := 0
	for altTravelTime <= (1+epsilon)*optTravelTime && iteration < maxIter {
		// applyPenalties

		penaltyEdgeCost := ars.applyPenalties(altEdgePath, optTravelTime)

		dirtyCells := ars.MarkDirtyCells(altEdgePath, s, t)
		updatedShortcutWeight := ars.engine.customizer.UpdateDirtyCells(
			ars.engine.costFunction, dirtyCells,
			penaltyEdgeCost, maxLevel,
		)

		crpQuery := NewCRPBidirectionalSearch(ars.engine, UPPERBOUND_SHORTEST_PATH)
		crpQuery.SetPenaltyEdgeCost(penaltyEdgeCost)
		crpQuery.SetShortcutEdgeCost(updatedShortcutWeight)

		altTravelTime, _, _, altEdgePath, found = crpQuery.ShortestPathSearch(asId, atId)
		if !found {
			break
		}

		if ars.isFeasible(newGraphVertexMap, H, altEdgePath, epsilon, optTravelTime) {
			ars.updateGraph(newGraphVertexMap, graphEdgeSet, altEdgePath, H)
		}
		iteration++
	}

	s, t = newGraphVertexMap[s], newGraphVertexMap[t]

	return ars.extractAlternatives(s, t, H, 2)
}

func (ars *AlternativeRouteSearch) extractAlternatives(s, t datastructure.Index, H *datastructure.DynamicGraph, k int,
) []*AlternativeRoute {
	optTravelTime, _, _, optEdgePath, _, distf, distb, found := ars.computeBidirectionalDijkstraOnAlternativeGraph(s, t, H)
	if !found {
		return []*AlternativeRoute{}
	}

	vias := make([]datastructure.Index, 0, H.NumberOfVertices())
	H.ForVertices(func(v *datastructure.Vertex) {
		vias = append(vias, v.GetID())
	})

	for i := len(vias) - 1; i >= 0; i-- {
		v := vias[i]
		if distf[v].getTravelTime()+distb[v].getTravelTime() > (1+ars.epsilon)*optTravelTime {
			vias = append(vias[:i], vias[i+1:]...)
		}
	}

	for _, v := range vias {
		if s == v || v == t {
			continue
		}
		svTravelTime, svDist, svCoords, svEdgePath, svFound := ars.computeShortestPathOnAlternativeGraph(s, v, H)
		vtTravelTime, vtDist, vtCoords, vtEdgePath, vtFound := ars.computeShortestPathOnAlternativeGraph(v, t, H)
		if !svFound || !vtFound {
			continue
		}

		pvEdgePath := append(svEdgePath, vtEdgePath...)
		sigmav := ars.calculateDistanceShare(optEdgePath, pvEdgePath)
		if sigmav >= ars.gamma*optTravelTime {
			continue
		}

		lv := svTravelTime + vtTravelTime
		lvExcludeOpt := lv - sigmav
		lOptExcludePv := optTravelTime - sigmav
		if lvExcludeOpt >= (1+ars.epsilon)*lOptExcludePv {
			continue
		}

		pvCoords := append(svCoords, vtCoords...)

		fv := 2*lv + sigmav
		ars.candidates =
			append(ars.candidates, NewAlternativeRoute(fv, svDist+vtDist, lv, v, pvCoords, pvEdgePath, datastructure.NewViaVertex(v, 0, 0, v)))

	}

	sort.Slice(ars.candidates, func(i, j int) bool {
		return ars.candidates[i].objectiveValue < ars.candidates[j].objectiveValue
	})

	ars.candidates = removeSimiliarAlternatives(ars.candidates)
	res := make([]*AlternativeRoute, 0, k)

	for i := 0; i < util.MinInt(k, len(ars.candidates)); i++ {
		res = append(res, ars.candidates[i])
	}

	return res
}

func (ars *AlternativeRouteSearch) isFeasible(graphVertexMap map[datastructure.Index]datastructure.Index, H *datastructure.DynamicGraph, altEdgePath []datastructure.OutEdge,
	epsilon, optTravelTime float64) bool {

	if ars.haveAdmissibleDetour(graphVertexMap, altEdgePath, optTravelTime, epsilon, H) {
		return true
	}

	return false
}

/*
Evolution and Evaluation of the Penalty Method for Alternative Graphs, Kobitzsch et al. (2013). page 98-99
Every path we find during the execution is evaluated by the aforenamed procedure for its
potential value to the alternative graph. We postulate that a path must offer at least one
deviation to the current alternative graph of length δ · D(s, t) or more, with δ usually chosen
as δ = 0.1 (compare Definition 3, limited sharing). The detours satisfying this requirement
are checked against the current alternative graph H for stretch. If one of these detours
between vertices a, b is not longer than (1 + \epsilon) · DH(a, b), its containing path is added to the
alternative graph. All other paths are rejected.
*/
func (ars *AlternativeRouteSearch) haveAdmissibleDetour(graphVertexMap map[datastructure.Index]datastructure.Index, altEdgepath []datastructure.OutEdge, optTravelTime, epsilon float64,
	H *datastructure.DynamicGraph) bool {

	detourLength := 0.0
	detourStartVid := datastructure.INVALID_VERTEX_ID

	for _, altEdge := range altEdgepath {
		head := altEdge.GetHead()
		tail := ars.engine.graph.GetTailOfOutedge(altEdge.GetEdgeId())
		_, tailInOtherSet := graphVertexMap[tail]
		_, headInOtherSet := graphVertexMap[head]

		if !headInOtherSet || !tailInOtherSet {
			if detourStartVid == datastructure.INVALID_VERTEX_ID {
				detourStartVid = tail
			}

			// detour path
			detourLength += ars.engine.metrics.GetWeight(&altEdge)
		} else if detourStartVid != datastructure.INVALID_VERTEX_ID {
			detourStartVid = graphVertexMap[detourStartVid]
			tail = graphVertexMap[tail]
			otherPathLength, _, _, _, _, _, _, found := ars.computeBidirectionalDijkstraOnAlternativeGraph(detourStartVid, tail, H)

			if found && detourLength >= ars.delta*optTravelTime && detourLength <= (1+epsilon)*otherPathLength {
				return true
			}

			detourStartVid = datastructure.INVALID_VERTEX_ID
			detourLength = 0.0
		}
	}

	return false
}

func (ars *AlternativeRouteSearch) computeBidirectionalDijkstraOnAlternativeGraph(s, t datastructure.Index, graph *datastructure.DynamicGraph,
) (float64, float64, []datastructure.Coordinate,
	[]datastructure.OutEdge, []datastructure.Index, map[datastructure.Index]altVertexInfo, map[datastructure.Index]altVertexInfo, bool) {
	pqf := datastructure.NewFourAryHeap[datastructure.AltQueryKey]()
	pqb := datastructure.NewFourAryHeap[datastructure.AltQueryKey]()

	distf := make(map[datastructure.Index]altVertexInfo)
	distb := make(map[datastructure.Index]altVertexInfo)

	distf[s] = NewAltVertexInfo(0, NewAltVertexPair(datastructure.INVALID_VERTEX_ID, datastructure.INVALID_EDGE_ID))
	pqf.Insert(datastructure.NewPriorityQueueNode(0, datastructure.NewAltQueryKey(s)))

	distb[t] = NewAltVertexInfo(0, NewAltVertexPair(datastructure.INVALID_VERTEX_ID, datastructure.INVALID_EDGE_ID))
	pqb.Insert(datastructure.NewPriorityQueueNode(0, datastructure.NewAltQueryKey(t)))

	mu := pkg.INF_WEIGHT
	mid := datastructure.INVALID_VERTEX_ID
	vias := make([]datastructure.Index, 0)

	for !pqf.IsEmpty() && !pqb.IsEmpty() {
		minF, minB := pqf.GetMinrank(), pqb.GetMinrank()

		u, _ := pqf.ExtractMin()
		uItem := u.GetItem()
		uId := uItem.GetVertex()

		graph.ForOutEdgesOf(uId, func(e *datastructure.OutEdge) {
			newTravelTime := distf[uId].getTravelTime() + ars.engine.metrics.GetWeight(e)

			v := e.GetHead()
			old, exists := distf[v]
			if !exists || newTravelTime < old.getTravelTime() {
				distf[v] = NewAltVertexInfo(newTravelTime, NewAltVertexPair(uId, e.GetEdgeId()))
				if !exists {
					pqf.Insert(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				} else {
					pqf.DecreaseKey(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				}
			}
			if _, visitedByBackward := distb[v]; visitedByBackward && newTravelTime+distb[v].getTravelTime() < mu {
				mu = newTravelTime + distb[v].getTravelTime()
				mid = v
				vias = append(vias, v)
			}
		})

		u, _ = pqb.ExtractMin()
		uItem = u.GetItem()
		uId = uItem.GetVertex()

		graph.ForInEdgesOf(uId, func(e *datastructure.InEdge) {
			newTravelTime := distb[uId].getTravelTime() + ars.engine.metrics.GetWeight(e)

			v := e.GetTail()
			old, exists := distb[v]
			if !exists || newTravelTime < old.getTravelTime() {
				distb[v] = NewAltVertexInfo(newTravelTime, NewAltVertexPair(uId, e.GetEdgeId()))
				if !exists {
					pqb.Insert(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				} else {
					pqb.DecreaseKey(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				}
			}

			if _, visitedByForward := distf[v]; visitedByForward && newTravelTime+distf[v].getTravelTime() < mu {
				mu = newTravelTime + distf[v].getTravelTime()
				mid = v
				vias = append(vias, v)
			}
		})

		if minF+minB >= mu {
			break
		}

	}

	if mu == pkg.INF_WEIGHT {
		return math.Inf(1), math.Inf(1), []datastructure.Coordinate{}, []datastructure.OutEdge{}, []datastructure.Index{}, distf, distb, false
	}

	totalDist := 0.0
	path := make([]datastructure.OutEdge, 0)
	coords := make([]datastructure.Coordinate, 0)

	prev := distf[mid]
	for prev.getParent().getVertex() != datastructure.INVALID_VERTEX_ID {
		eId := prev.getParent().getOutEdge()
		e := ars.engine.graph.GetOutEdge(eId)
		path = append(path, *e)

		totalDist += e.GetLength()
		prevVertex := prev.getParent().getVertex()

		prevV := graph.GetVertex(prevVertex)
		coords = append(coords, datastructure.NewCoordinate(
			prevV.GetLat(), prevV.GetLon(),
		))
		prev = distf[prevVertex]
	}
	sV := graph.GetVertex(s)
	coords = append(coords, datastructure.NewCoordinate(sV.GetLat(), sV.GetLon()))

	path = util.ReverseG[datastructure.OutEdge](path)
	coords = util.ReverseG(coords)

	prev = distb[mid]
	for prev.getParent().getVertex() != datastructure.INVALID_VERTEX_ID {
		eId := prev.getParent().getOutEdge()
		e := ars.engine.graph.GetOutEdge(eId)
		path = append(path, *e)

		totalDist += e.GetLength()
		prevVertex := prev.getParent().getVertex()

		prevV := graph.GetVertex(prevVertex)
		coords = append(coords, datastructure.NewCoordinate(
			prevV.GetLat(), prevV.GetLon(),
		))
		prev = distb[prevVertex]
	}
	tV := graph.GetVertex(t)
	coords = append(coords, datastructure.NewCoordinate(tV.GetLat(), tV.GetLon()))

	return mu, totalDist, coords, path, vias, distf, distb, true
}

func (ars *AlternativeRouteSearch) computeShortestPathOnAlternativeGraph(s, t datastructure.Index, graph *datastructure.DynamicGraph,
) (float64, float64, []datastructure.Coordinate,
	[]datastructure.OutEdge, bool) {
	pq := datastructure.NewFourAryHeap[datastructure.AltQueryKey]()
	dist := make(map[datastructure.Index]altVertexInfo)

	dist[s] = NewAltVertexInfo(0, NewAltVertexPair(datastructure.INVALID_VERTEX_ID, datastructure.INVALID_EDGE_ID))

	pq.Insert(datastructure.NewPriorityQueueNode(0, datastructure.NewAltQueryKey(s)))
	for !pq.IsEmpty() {
		u, _ := pq.ExtractMin()
		uItem := u.GetItem()
		uId := uItem.GetVertex()

		uTravelTime := u.GetRank()
		if uId == t {
			totalDist := 0.0
			path := make([]datastructure.OutEdge, 0)

			prev := dist[t].getParent()
			coords := make([]datastructure.Coordinate, 0)

			tV := graph.GetVertex(t)
			coords = append(coords, datastructure.NewCoordinate(tV.GetLat(), tV.GetLon()))

			for prev.getVertex() != datastructure.INVALID_VERTEX_ID {
				edge := *ars.engine.graph.GetOutEdge(prev.getOutEdge())
				path = append(path, edge)
				totalDist += edge.GetLength()

				edgeGeom := ars.engine.graph.GetEdgeGeometry(prev.getOutEdge())
				revEdgeGeom := util.ReverseG(edgeGeom)

				coords = append(coords, revEdgeGeom...)

				prev = dist[prev.getVertex()].getParent()
			}
			path = util.ReverseG(path)
			coords = util.ReverseG(coords)

			return uTravelTime, totalDist, coords, path, true
		}

		graph.ForOutEdgesOf(uId, func(e *datastructure.OutEdge) {
			newTravelTime := dist[uId].getTravelTime() + e.GetWeight()

			v := e.GetHead()
			old, exists := dist[v]
			if !exists || newTravelTime < old.getTravelTime() {
				dist[v] = NewAltVertexInfo(newTravelTime, NewAltVertexPair(uId, e.GetEdgeId()))
				if !exists {
					pq.Insert(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				} else {
					pq.DecreaseKey(datastructure.NewPriorityQueueNode(newTravelTime, datastructure.NewAltQueryKey(v)))
				}
			}
		})
	}

	return math.Inf(1), math.Inf(1), []datastructure.Coordinate{}, []datastructure.OutEdge{}, false
}

func (ars *AlternativeRouteSearch) applyPenalties(penaltiedArcs []datastructure.OutEdge, optTravelTime float64) map[datastructure.PenaltiedEdge]float64 {
	penaltyEdgeCost := make(map[datastructure.PenaltiedEdge]float64, len(penaltiedArcs))
	adjointPenalty := 0.5 * math.Sqrt(optTravelTime)
	pathPenalty := (1 + 0.04)

	for i := 0; i < len(penaltiedArcs); i++ {
		arc := penaltiedArcs[i]
		if _, exists := penaltyEdgeCost[datastructure.NewPenaltiedEdge(arc.GetEdgeId(), true)]; !exists {
			penaltyEdgeCost[datastructure.NewPenaltiedEdge(arc.GetEdgeId(), true)] = ars.engine.metrics.GetWeight(&arc)
		}
		penaltyEdgeCost[datastructure.NewPenaltiedEdge(arc.GetEdgeId(), true)] *= pathPenalty

		head := arc.GetHead()
		inArc := ars.engine.graph.GetInEdge(datastructure.Index(arc.GetEntryPoint()) + ars.engine.graph.GetEntryOffset(head))

		if _, exists := penaltyEdgeCost[datastructure.NewPenaltiedEdge(inArc.GetEdgeId(), false)]; !exists {
			penaltyEdgeCost[datastructure.NewPenaltiedEdge(inArc.GetEdgeId(), false)] = ars.engine.metrics.GetWeight(inArc)
		}
		penaltyEdgeCost[datastructure.NewPenaltiedEdge(inArc.GetEdgeId(), false)] *= pathPenalty

		// give penalty to adjoined arcs
		tail := ars.engine.graph.GetTailOfOutedge(arc.GetEdgeId())
		ars.engine.graph.ForOutEdgesOfWithId(tail, func(adjoinedArc *datastructure.OutEdge, id datastructure.Index) {
			if adjoinedArc.GetEdgeId() == arc.GetEdgeId() {
				return
			}
			if _, exists := penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedArc.GetEdgeId(), true)]; !exists {
				penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedArc.GetEdgeId(), true)] = ars.engine.metrics.GetWeight(adjoinedArc)
			}
			penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedArc.GetEdgeId(), true)] += adjointPenalty

			adjoinedArcHead := adjoinedArc.GetHead()
			adjoinedInArc := ars.engine.graph.GetInEdge(datastructure.Index(adjoinedArc.GetEntryPoint()) + ars.engine.graph.GetEntryOffset(adjoinedArcHead))

			if _, exists := penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedInArc.GetEdgeId(), true)]; !exists {
				penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedInArc.GetEdgeId(), true)] = ars.engine.metrics.GetWeight(adjoinedInArc)
			}
			penaltyEdgeCost[datastructure.NewPenaltiedEdge(adjoinedInArc.GetEdgeId(), true)] += adjointPenalty

		})
	}
	return penaltyEdgeCost
}

func (ars *AlternativeRouteSearch) MarkDirtyCells(path []datastructure.OutEdge, s, t datastructure.Index) []datastructure.DirtyCell {
	q := make(map[datastructure.DirtyCell]struct{}, 0)
	d := make([]datastructure.DirtyCell, 0, 10)

	sCell := ars.engine.graph.GetCellNumber(s)
	tCell := ars.engine.graph.GetCellNumber(t)

	for _, e := range path {
		v := e.GetHead()
		vCell := ars.engine.graph.GetCellNumber(v)

		vQueryLevel := ars.engine.overlayGraph.GetQueryLevel(sCell, tCell,
			vCell)
		dirtyCell := datastructure.NewDirtyCell(vCell, int(vQueryLevel))
		if _, seen := q[dirtyCell]; vQueryLevel != 0 && !seen {
			q[dirtyCell] = struct{}{}
			d = append(d, dirtyCell)
		}
	}

	return d
}

func (ars *AlternativeRouteSearch) updateGraph(graphVertexMap map[datastructure.Index]datastructure.Index, graphEdgeSet map[datastructure.Index]struct{},
	path []datastructure.OutEdge, graph *datastructure.DynamicGraph) {
	for i := 0; i < len(path); i++ {
		e := path[i]

		tail := ars.engine.graph.GetTailOfOutedge(e.GetEdgeId())
		tailV := ars.engine.graph.GetVertex(tail)

		head := e.GetHead()
		headV := ars.engine.graph.GetVertex(head)

		newTail, tailExists := graphVertexMap[tail]
		if tailExists {
			tail = newTail
		} else {

			newTail = graph.AddVertex(tailV)
			graphVertexMap[tail] = newTail
			tail = newTail
		}

		newHead, headExists := graphVertexMap[head]
		if headExists {
			head = newHead
		} else {
			newHead = graph.AddVertex(headV)
			graphVertexMap[head] = newHead

			head = newHead
		}

		if _, exists := graphEdgeSet[e.GetEdgeId()]; exists {
			continue
		}
		graphEdgeSet[e.GetEdgeId()] = struct{}{}

		graph.AddEdge(tail, head, e)
	}
}
