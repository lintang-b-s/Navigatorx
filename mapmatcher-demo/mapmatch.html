<!DOCTYPE html>
<html>
  <head>
    <title>Map Match</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      #map {
        height: 500px;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="controls">
      <input type="file" id="gpsJson" accept=".json" />
      <button id="uploadButton">Upload gps data</button>
    </div>
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script src="
https://cdn.jsdelivr.net/npm/@mapbox/polyline@1.2.1/src/polyline.min.js
"></script>

    <script>
      function drawPolyline(encodedPath) {
        try {
          var decodedCoords = polyline.decode(encodedPath);

          var latLngs = decodedCoords.map((coord) => [coord[0], coord[1]]);

          var polylineLayer = L.polyline(latLngs, { color: "blue" }).addTo(map);

          map.fitBounds(polylineLayer.getBounds());
        } catch (error) {
          console.error("Error decoding polyline:", error);
          alert("Failed to decode polyline");
        }
      }

      var map = L.map("map").setView([47.66755, -122.1065], 15);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 19,
      }).addTo(map);

      document
        .getElementById("uploadButton")
        .addEventListener("click", function () {
          var fileInput = document.getElementById("gpsJson");
          if (fileInput.files.length === 0) {
            alert("Please select a JSON file");
            return;
          }
          var file = fileInput.files[0];
          var reader = new FileReader();

          reader.onload = async function (e) {
            try {
              var requestData = JSON.parse(e.target.result);
            } catch (err) {
              console.error("Invalid JSON file:", err);
              alert("Invalid JSON file!");
              return;
            }

            function haversine(lat1, lon1, lat2, lon2) {
              const R = 6371000;
              const toRad = (x) => (x * Math.PI) / 180;
              const dLat = toRad(lat2 - lat1);
              const dLon = toRad(lon2 - lon1);
              const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) *
                  Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) *
                  Math.sin(dLon / 2);
              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              return R * c;
            }

            let candidates = [];
            let speedMeanK = 500.0;
            let speedStdK = 500.0;

            let prev = null;
            let prevTime = null;
            const defaultConstantSpeed = 500.0; // meter/min
            let defaultSamplingInterval = 1.0 / 60; // default 1s
            let lastBearing = 0.0;

            const startTime = new Date(requestData[0].datetime_utc);
            const endTime = new Date(
              requestData[requestData.length - 1].datetime_utc
            );

            for (
              let currentTime = new Date(startTime);
              currentTime <= endTime;
              currentTime = new Date(currentTime.getTime() + 1000)
            ) {
              const point = requestData.find((p) => {
                const t = new Date(p.datetime_utc);
                return Math.abs(t - currentTime) < 1000;
              });

              let mapMatchRequest = null;
              let deadReckoning = false;
              console.log("currentTime: ", currentTime);

              if (point) {
                const t = new Date(point.datetime_utc);
                let speed = 0;
                let dt_minutes = 0.0;

                if (prev) {
                  const prevTime = new Date(prev.datetime_utc);
                  dt_minutes = (t - prevTime) / 60000.0; // ms to minutes
                  const distance = haversine(
                    prev.Latitude,
                    prev.Longitude,
                    point.Latitude,
                    point.Longitude
                  );
                  if (dt_minutes > 0) {
                    speed = distance / dt_minutes;
                  }
                }

                mapMatchRequest = {
                  gps_point: {
                    lat: point.Latitude,
                    lon: point.Longitude,
                    time: t.toISOString(),
                    speed: speed,
                    delta_time: dt_minutes,
                    dead_reckoning: false,
                  },
                  k: Math.round((t - startTime) / 1000) + 1,
                  candidates: candidates,
                  speed_mean_k: speedMeanK,
                  speed_std_k: speedStdK,
                  last_bearing: lastBearing,
                };

                prev = point;
                prev = point;
                prevTime = t;
              } else {
                console.log(
                  "dead reckoning...., prev coord: ",
                  prev.Latitude,
                  prev.Longitude
                );
                deadReckoning = true;

                mapMatchRequest = {
                  gps_point: {
                    lat: prev ? prev.Latitude : 0,
                    lon: prev ? prev.Longitude : 0,
                    time: currentTime.toISOString(),
                    speed: defaultConstantSpeed,
                    delta_time: prevTime
                      ? (currentTime - prevTime) / 60000.0
                      : defaultSamplingInterval,
                    dead_reckoning: true,
                  },
                  k: Math.round((currentTime - startTime) / 1000) + 1,
                  candidates: candidates,
                  speed_mean_k: speedMeanK,
                  speed_std_k: speedStdK,
                  last_bearing: lastBearing,
                };
                prevTime = currentTime;
              }

              try {
                const response = await fetch(
                  "http://localhost:6060/api/onlineMapMatch",
                  {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(mapMatchRequest),
                  }
                );
                const apiResponse = await response.json();
                candidates = apiResponse.data.candidates || [];
                speedMeanK = apiResponse.data.speed_mean_k;
                speedStdK = apiResponse.data.speed_std_k;
                lastBearing = apiResponse.data.edge_initial_bearing;

                if (!deadReckoning && point) {
                  L.circleMarker([point.Latitude, point.Longitude], {
                    color: "red",
                    radius: 4,
                    fillOpacity: 1,
                  }).addTo(map);
                }

                if (
                  apiResponse.data.matched_gps_point &&
                  apiResponse.data.matched_gps_point.matched_coord
                ) {
                  const matched =
                    apiResponse.data.matched_gps_point.matched_coord;
                  L.circleMarker([matched.lat, matched.lon], {
                    color: "green",
                    radius: 4,
                    fillOpacity: 1,
                  }).addTo(map);
                }

                if (deadReckoning) {
                  prev.Latitude =
                    apiResponse.data.matched_gps_point.predicted_gps_coord.lat;
                  prev.Longitude =
                    apiResponse.data.matched_gps_point.predicted_gps_coord.lon;
                }
              } catch (error) {
                console.error("Error:", error);
                alert("Error during map matching");
                return;
              }

              await new Promise((resolve) => setTimeout(resolve, 1));
            }
          };

          reader.readAsText(file);
        });
    </script>
  </body>
</html>
